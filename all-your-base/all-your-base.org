#+title: All Your Base IELM testing

* Stuff from weeks ago

#+begin_src emacs-lisp
ELISP> (string-to-number (mapconcat #'identity '("3" "1" "0") ""))
310 (#o466, #x136)
ELISP> (string-to-number (mapconcat #'string '(4 2) ""))
0 (#o0, #x0, ?\C-@)
ELISP> (string-to-number (mapconcat #'identity (mapcar #'string '(4 2)) ""))
0 (#o0, #x0, ?\C-@)
ELISP> (string-to-number (mapconcat #'number-to-string '(4 2) ""))
42 (#o52, #x2a, ?*)
#+end_src

First attempt that got horribly botched

#+begin_src emacs-lisp
(defun rebase (list-of-digits in-base out-base)
  ;; this is just all wrong
  (defun __base10-to-base-n (__base10-digits n)
    "Convert list of digits in base-10 to list of digits in base-n."
    (defun __base10-to-base-n-helper (__base10-num n power accumulator)
      (if (eq __base10-num 0)
          accumulator
        (let* ((divisor (expt n power))
               ;; (remainder (mod __base10-num divisor))
               (remainder (% __base10-num divisor))
               (quotient (/ __base10-num divisor)))
          (__base10-to-base-n-helper
           quotient
           n
           (1+ power)
           (cons remainder accumulator)))))
    (let ((__base10-number (string-to-number
                            (mapconcat #'number-to-string __base10-digits ""))))
      (__base10-to-base-n-helper __base10-number n 0 '())))
  (defun __base-n-to-base10 (__base-n-digits n accumulator)
    "Convert list of digits in base-n to base-10."
    (if __base-n-digits
        (let ((power (1- (length __base-n-digits)))
              (x (car __base-n-digits)))
          ;; recursive step
          (__base-n-to-base10
           (cdr __base-n-digits)
           n
           (cons (* x (expt n power)) accumulator)))
      (apply #'+ accumulator)))
  (error "Delete this S-Expression and write your own implementation"))
#+end_src

* =base-n-to-base-10=

#+begin_src emacs-lisp
  (defun base-n-to-base-10 (digits base-n)
    "Convert DIGITS from BASE-N to base 10 (output is a number)."
    (defun n-to-10-helper (digits base-n acc)
      (if digits
          (let* ((digit (car digits))
                 (power (1- (length digits)))
                 (base-10 (* digit (expt base-n power))))
            (print (format (concat "digit: %d\t"
                                   "power: %d\t"
                                   "base-10: %d\t"
                                   "acc: %d")
                           digit power base-10 acc))
            (n-to-10-helper (cdr digits) base-n (+ base-10 acc))))
      acc)
    (n-to-10-helper digits base-n 0))
#+end_src

Not working, so let's dig into it:

#+begin_src emacs-lisp
  ELISP> (base-n-to-base-10 '(1 0 1 0 1 0) 2)

  "digit: 1   power: 5    base-10: 32 acc: 0"

  "digit: 0   power: 4    base-10: 0  acc: 32"

  "digit: 1   power: 3    base-10: 8  acc: 32"

  "digit: 0   power: 2    base-10: 0  acc: 40"

  "digit: 1   power: 1    base-10: 2  acc: 40"

  "digit: 0   power: 0    base-10: 0  acc: 42"

  0 (#o0, #x0, ?\C-@)
#+end_src

So the 42 is in the accumulator, I just need to get it out.

#+begin_src emacs-lisp
(defun base-n-to-base-10 (digits base-n)
  "Convert DIGITS from BASE-N to base 10 (output is a number)."
  (defun n-to-10-helper (digits base-n acc)
    (if digits
        (let* ((digit (car digits))
               (power (1- (length digits)))
               (base-10 (* digit (expt base-n power))))
          (print (format (concat "digit: %d\t"
                                 "power: %d\t"
                                 "base-10: %d\t"
                                 "acc: %d")
                         digit power base-10 acc))
          (n-to-10-helper (cdr digits) base-n (+ base-10 acc)))
      acc))
  (n-to-10-helper digits base-n 0))
#+end_src

I just had the accumulator in the wrong place/at the wrong level of
parentheses. The print statement really helped with the debugging!
