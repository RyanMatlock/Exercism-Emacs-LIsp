#+title: Sublist IELM testing results

It's probably better to organize my IELM experiments into literate code blocks.

ELISP> (compare-equal-length-lists '("foo" "bar") '("bar" "foo"))
:unequal
ELISP> (compare-equal-length-lists '(1 2 3) '(1 2 3))
:equal

ELISP> (slice '(1 2 3 4 5) 1 3)
(2 3 4)

ELISP> (slice '(1 2 3 4 5) 2 3)
(3 4 5)

ELISP> (slice '(1 2 3 4 5) 1 5)
(2 3 4 5 nil)
oops, going off the end

ELISP> (slice '(1 2 3 4 5) 1 6)
(2 3 4 5 nil nil)
really going off the end!

ELISP> (slice '(1 2 3 4 5) 1 7)
*** Eval error ***  Slice is too large.

ELISP> (slice '(1 2 3 4 5) 1 5)
*** Eval error ***  Slice is too large.
ELISP> (slice '(1 2 3 4 5) 1 4)
(2 3 4 5)

ELISP> (slice '(1 2 3 4 5) 0 5)
(1 2 3 4 5)
fixed

ELISP> (longer-list '(1 2 3) '(1 2 3 4))
:second
ELISP> (longer-list '(1 2 3) '())
:first
ELISP> (longer-list '(1 2 3) '(3 2 1))
:equal

ELISP> (equal :first :first)
t
ELISP> (eq :first :first)
t
ELISP> (eq :first :second)
nil
ELISP> (equal :first :second)
nil
ok, that works as expected

ELISP> (mapcar #'(lambda (x y) (eq x y)) '(1 2 3) '(3 2 1))
*** Eval error ***  Wrong number of arguments: mapcar, 3
ELISP> (seq-mapn #'(lambda (x y) (eq x y)) '(1 2 3) '(3 2 1))
(nil t nil)

ELISP> (seq-reduce #'and (seq-mapn #'(lambda (x y) (eq x y)) '(1 2 3) '(3 2 1))
t)
*** Eval error ***  Invalid function: #<subr and>
ELISP> (seq-reduce 'and '(t t nil) t)
*** Eval error ***  Invalid function: #<subr and>
ELISP> (seq-reduce #'(lambda (x y) (and x y)) '(t t nil) t)
nil
ELISP> (seq-reduce #'(lambda (x y) (and x y)) '(t t t) t)
t
ELISP> (functionp 'and)
nil
ELISP> (functionp 'length)
t
see
https://emacs.stackexchange.com/questions/16332/and-is-an-invalid-function
well, that's weird about #'and, but it's good to know, and it's really good
to know about seq-mapn for essentially being able to zip lists

ELISP> (seq-mapn #'(lambda (x y) (cons x y)) '(:foo :bar :baz) '(1 2 3 4))
((:foo . 1)
 (:bar . 2)
 (:baz . 3))
looks like I'll probably be able to make my code a lot shorter

ELISP> (defun any (bools) (seq-reduce #'(lambda (x y) (or x y)) bools nil))
any
ELISP> (any '(nil nil t))
t

ELISP> (equal '(:foo :bar) '(:foo :bar))
t
ELISP> (equal '('(:foo) '(:bar)) '((quote (:foo)) (quote (:bar))))
t
ELISP> (equal '("foo" "bar") (quote ("foo" "bar")))
t
ELISP> (equal '("bar" "foo") (quote ("foo" "bar")))
nil
ok, so equal seems to be pretty smart
