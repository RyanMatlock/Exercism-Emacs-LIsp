#+title: Sublist IELM testing results

It's probably better to organize my IELM experiments into literate code blocks.

* ~compare-equal-length-lists~ tests
#+begin_src emacs-lisp
ELISP> (compare-equal-length-lists '("foo" "bar") '("bar" "foo"))
:unequal
ELISP> (compare-equal-length-lists '(1 2 3) '(1 2 3))
:equal
#+end_src

* ~slice~ tests
#+begin_src emacs-lisp
ELISP> (slice '(1 2 3 4 5) 1 3)
(2 3 4)

ELISP> (slice '(1 2 3 4 5) 2 3)
(3 4 5)

ELISP> (slice '(1 2 3 4 5) 1 5)
(2 3 4 5 nil)
#+end_src

oops, going off the end

#+begin_src emacs-lisp
ELISP> (slice '(1 2 3 4 5) 1 6)
(2 3 4 5 nil nil)
#+end_src

really going off the end!

#+begin_src emacs-lisp
ELISP> (slice '(1 2 3 4 5) 1 7)
*** Eval error ***  Slice is too large.

ELISP> (slice '(1 2 3 4 5) 1 5)
*** Eval error ***  Slice is too large.
ELISP> (slice '(1 2 3 4 5) 1 4)
(2 3 4 5)

ELISP> (slice '(1 2 3 4 5) 0 5)
(1 2 3 4 5)
#+end_src
fixed

* ~longer-list~ testing

#+begin_src emacs-lisp
ELISP> (longer-list '(1 2 3) '(1 2 3 4))
:second
ELISP> (longer-list '(1 2 3) '())
:first
ELISP> (longer-list '(1 2 3) '(3 2 1))
:equal
#+end_src

* Ensuring I know how Emacs Lisp keywords work
see [[https://stackoverflow.com/a/25921867][What is the colon (:) in Emacs lisp? | stackoverflow]]

#+begin_src emacs-lisp
ELISP> (equal :first :first)
t
ELISP> (eq :first :first)
t
ELISP> (eq :first :second)
nil
ELISP> (equal :first :second)
nil
#+end_src

ok, that works as expected

* Demonstrating I don't understand how to zip lists

#+begin_src emacs-lisp
ELISP> (mapcar #'(lambda (x y) (eq x y)) '(1 2 3) '(3 2 1))
*** Eval error ***  Wrong number of arguments: mapcar, 3
ELISP> (seq-mapn #'(lambda (x y) (eq x y)) '(1 2 3) '(3 2 1))
(nil t nil)

ELISP> (seq-reduce #'and (seq-mapn #'(lambda (x y) (eq x y)) '(1 2 3) '(3 2 1))
t)
*** Eval error ***  Invalid function: #<subr and>
ELISP> (seq-reduce 'and '(t t nil) t)
*** Eval error ***  Invalid function: #<subr and>
ELISP> (seq-reduce #'(lambda (x y) (and x y)) '(t t nil) t)
nil
ELISP> (seq-reduce #'(lambda (x y) (and x y)) '(t t t) t)
t
ELISP> (functionp 'and)
nil
ELISP> (functionp 'length)
t
see
https://emacs.stackexchange.com/questions/16332/and-is-an-invalid-function
well, that's weird about #'and, but it's good to know, and it's really good
to know about seq-mapn for essentially being able to zip lists

ELISP> (seq-mapn #'(lambda (x y) (cons x y)) '(:foo :bar :baz) '(1 2 3 4))
((:foo . 1)
 (:bar . 2)
 (:baz . 3))
looks like I'll probably be able to make my code a lot shorter

ELISP> (defun any (bools) (seq-reduce #'(lambda (x y) (or x y)) bools nil))
any
ELISP> (any '(nil nil t))
t

ELISP> (equal '(:foo :bar) '(:foo :bar))
t
ELISP> (equal '('(:foo) '(:bar)) '((quote (:foo)) (quote (:bar))))
t
ELISP> (equal '("foo" "bar") (quote ("foo" "bar")))
t
ELISP> (equal '("bar" "foo") (quote ("foo" "bar")))
nil
ok, so equal seems to be pretty smart

#+end_src

* Failing ~successive-sublists-expected-behavior~

#+begin_example
F successive-sublists-expected-behavior
    (error "Slice is too large.")
#+end_example

Current state of ~successive-sublists~:

#+begin_src emacs-lisp
  (defun successive-sublists (xs size)
    "Break XS into as many sublists of length SIZE as possible and return as a
  list of lists; e.g.

  (successive-sublists '(:foo :bar :baz :qux) 2) ->
  ('(:foo :bar) '(:bar :baz) '(:baz :qux))"
    (defun successive-sublists-helper (xs size start acc)
      (if (> (- size start) (length xs))
          (reverse acc)
        (print (format "xs: %s\tsize: %d\tstart: %d\tacc: %s"
                       xs size start acc))
        (successive-sublists-helper
         xs
         size
         (1+ start)
         (cons (slice xs start size) acc))))
    (cond ((> size (length xs))
           (error "SIZE must be â‰¤ (length XS)"))
          ((and (equal size 0) (not xs)) '())
          ((equal size 0)
           (error "SIZE must be > 0 if XS is non-empty"))
          (t (successive-sublists-helper xs size 0 '()))))
#+end_src

#+begin_src emacs-lisp
ELISP> (successive-sublists '(:foo :bar :baz) 2)

"xs: (:foo :bar :baz)   size: 2 start: 0    acc: nil"

"xs: (:foo :bar :baz)   size: 2 start: 1    acc: ((:foo :bar))"

"xs: (:foo :bar :baz)   size: 2 start: 2    acc: ((:bar :baz) (:foo :bar))"

*** Eval error ***  Slice is too large.
#+end_src

Ah, I just need to check that the difference between size and start is less
than or equal to size.
